/**
 * SPDX-License-Identifier: MPL-2.0
 * SPDX-FileCopyrightText: 2025 Lutz Br√ºckner <dev@kahuna.rocks>
 */

import type { PlainObject } from './types/common.ts';
import type { AllowedType } from './value-formatter.ts';

/**
 * get type of value as lowercase string
 */
const objectRegexp = /^\[object (\S+)\]$/;
export const getType = (val: unknown): AllowedType => {
    const type = typeof val;
    // all primitives and function
    if (type !== 'object') {
        return type as AllowedType;
    }
    // everything else
    return Object.prototype.toString
        .call(val)
        .replace(objectRegexp, '$1')
        .toLowerCase() as AllowedType;
};

/**
 * compare values of types that are supported as index
 * https://dexie.org/docs/Indexable-Type
 */
export const compareIndexValues = (a: never, b: never): boolean => {
    const ta = getType(a);
    const tb = getType(b);
    if (ta !== tb) {
        return false;
    }
    if (['number', 'string'].includes(ta)) {
        return a === b;
    }
    if (
        ['array', 'date', 'arraybuffer'].includes(ta) ||
        typedarrayTypes.includes(ta as TypedArrayType)
    ) {
        return JSON.stringify(a) === JSON.stringify(b);
    }
    return false;
};

const unquotedStringProperties = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/u;

export const maybeQuotedProperty = (prop: string | number) => {
    return (typeof prop === 'number' && isNaN(prop) === false) ||
        (typeof prop === 'string' && unquotedStringProperties.test(prop))
        ? prop
        : quotedString(String(prop));
};

export const quotedString = (val: string) => {
    if (val.includes("'")) {
        if (val.includes('"')) {
            return `"${val.replaceAll('"', '\\"')}"`;
        } else {
            return `"${val}"`;
        }
    } else {
        return `'${val}'`;
    }
};

export const isUnquotedPropertyName = (name: string) =>
    unquotedStringProperties.test(name);

export const typedarrayTypes = [
    'int8array',
    'int16array',
    'int32array',
    'uint8array',
    'uint16array',
    'uint32array',
    'uint8clampedarray',
    'bigint64array',
    'biguint64array',
    'float32array',
    'float64array',
] as const;

export type TypedArrayType = (typeof typedarrayTypes)[number];

/*
 * Data types for which the old row.prop value is used in datatable.editRow()
 * instead of representing the value as code generated by valueToSource()
 */
export const typesFromRow = [
    'blob',
    'dataview',
    'rtccertificate',
    'imagedata',
    'imagebitmap',
    'file',
    'filelist',
    'filesystemdirectoryhandle',
    'filesystemfilehandle',
    'gpucompilationmessage',
    'gpucompilationinfo',
    'cryptokey',
    'videoframe',
    'audiodata',
    'croptarget',
] as const;

export const shallowEqual = (object1: PlainObject, object2: PlainObject) => {
    if (!isPlainObject(object1) || !isPlainObject(object2)) {
        return false;
    }
    const keys1 = Object.keys(object1);
    const keys2 = Object.keys(object2);
    if (keys1.length !== keys2.length) {
        return false;
    }

    for (const key of keys1) {
        if (object1[key] !== object2[key]) {
            return false;
        }
    }

    return true;
};

export const isPlainObject = (value: any) => value?.constructor === Object;

export const isEmptyObject = (value: any) => {
    if (!isPlainObject(value)) return false;
    for (const property in value) {
        if (Object.hasOwn(value, property)) return false;
    }
    return true;
};
